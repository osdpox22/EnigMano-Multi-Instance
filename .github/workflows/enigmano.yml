name: EnigMano Instance Deployment

on:
  workflow_dispatch:
    inputs:
      INSTANCE:
        description: "Instance number to deploy (e.g., 1, 2, 3...)"
        required: true
        default: "1"

jobs:
  deploy-enigmano:
    runs-on: windows-latest

    env:
      INSTANCE_ID: ${{ github.event.inputs.INSTANCE }}
      SECRET_SHAHZAIB: ${{ secrets.SECRET_SHAHZAIB }}
      NGROK_SHAHZAIB: ${{ secrets.NGROK_SHAHZAIB }}
      REPO: ${{ github.repository }}
      WORKFLOW_FILE: enigmano.yml
      DEPLOYMENT_ID: ${{ github.run_id }}
      # TODO: paste your Bot.zip direct link here
      BOT_ZIP_URL: "https://REPLACE_WITH_YOUR_DIRECT_ZIP_LINK"

    steps:
      - name: Deployment Parameters
        shell: pwsh
        run: |
          $prevInstance = [int]$env:INSTANCE_ID - 1
          Write-Host "==============================================="
          Write-Host "Instance ID          : $env:INSTANCE_ID"
          Write-Host "Previous Instance    : $prevInstance"
          Write-Host "Repository           : $env:REPO"
          Write-Host "Workflow File        : $env:WORKFLOW_FILE"
          Write-Host "Deployment ID        : $env:DEPLOYMENT_ID"
          Write-Host "==============================================="

      - name: Validate Secrets
        shell: pwsh
        run: |
          if (-not $env:SECRET_SHAHZAIB) { Write-Error "Missing GitHub Secret: SECRET_SHAHZAIB"; exit 1 }
          if (-not $env:NGROK_SHAHZAIB) { Write-Error "Missing Ngrok Auth Token: NGROK_SHAHZAIB"; exit 1 }
          Write-Host "All required secrets validated successfully"

      - name: Ensure RDP enabled and resilient ngrok TCP tunnel
        shell: pwsh
        env:
          GITHUB_STEP_SUMMARY: ${{ github.step_summary }}
        run: |
          $ErrorActionPreference = 'Stop'
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

          # 1) Enable RDP (idempotent)
          try {
            Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
            Enable-NetFirewallRule -DisplayGroup "Remote Desktop" | Out-Null
            Write-Host "RDP enabled and firewall rule ensured."
          } catch {
            Write-Host "Warning: could not fully ensure RDP settings: $($_.Exception.Message)"
          }

          # 2) Ensure ngrok
          $ngrokDir = "C:\Users\runneradmin\ngrok"
          $ngrokExe = Join-Path $ngrokDir "ngrok.exe"
          if (-not (Test-Path $ngrokExe)) {
            New-Item -ItemType Directory -Force -Path $ngrokDir | Out-Null
            $zip = Join-Path $ngrokDir "ngrok.zip"
            Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-stable-windows-amd64.zip" -OutFile $zip -UseBasicParsing
            Expand-Archive -Path $zip -DestinationPath $ngrokDir -Force
            Remove-Item $zip -Force
          }

          # 3) Authenticate
          & $ngrokExe config add-authtoken $env:NGROK_SHAHZAIB | Out-Null

          # 4) Prepare log files
          $logFile = Join-Path $ngrokDir "ngrok.log"
          $urlFile = Join-Path $ngrokDir "ngrok-url.txt"
          if (Test-Path $logFile) { Remove-Item -LiteralPath $logFile -Force -ErrorAction SilentlyContinue }
          if (Test-Path $urlFile) { Remove-Item -LiteralPath $urlFile -Force -ErrorAction SilentlyContinue }

          # Helper: let ngrok write its own log file (avoids file lock)
          function Start-Ngrok {
            param([string]$Args = "tcp 3389 --log=`"$logFile`" --log-format=logfmt --log-level=info")
            $psi = New-Object System.Diagnostics.ProcessStartInfo
            $psi.FileName = $ngrokExe
            $psi.Arguments = $Args
            $psi.UseShellExecute = $true
            $psi.CreateNoWindow = $true
            [System.Diagnostics.Process]::Start($psi) | Out-Null
          }

          # 5) Monitor ngrok and keep URL published for 180 minutes
          $monitorMinutes = 180
          $pollSeconds    = 4
          $loops          = [Math]::Ceiling(($monitorMinutes*60) / $pollSeconds)
          $currentUrl     = $null

          Start-Ngrok
          Write-Host "ngrok started."

          for ($i = 1; $i -le $loops; $i++) {
            Start-Sleep -Seconds $pollSeconds

            # Extract URL if present in log; pattern: tcp://host:port
            if (Test-Path $logFile) {
              $txt = Get-Content -LiteralPath $logFile -Raw -ErrorAction SilentlyContinue
              if ($txt -match 'tcp://[0-9a-zA-Z\.-]+:\d+') {
                $found = $Matches[0]
                if ($found -ne $currentUrl) {
                  $currentUrl = $found
                  Set-Content -LiteralPath $urlFile -Value $currentUrl -Encoding ASCII
                  Write-Host ("[ngrok] RDP address: {0}" -f $currentUrl)
                  Add-Content -LiteralPath $env:GITHUB_STEP_SUMMARY -Value ("## RDP (ngrok)\n\n- Address: `{0}`\n- Username: `runneradmin`\n- Password: set by your script\n\n" -f $currentUrl)
                }
              }
            }

            # If ngrok died, restart it and reset URL so we publish a fresh one
            $running = Get-Process -Name ngrok -ErrorAction SilentlyContinue
            if (-not $running) {
              Write-Host "ngrok not running; restarting..."
              if (Test-Path $logFile) { Remove-Item -LiteralPath $logFile -Force -ErrorAction SilentlyContinue }
              Start-Ngrok
              $currentUrl = $null
            }
          }

          Write-Host "ngrok monitor window finished."

      - name: Download and extract Bot to C:\Users\runneradmin\Downloads\Bot
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

          $BOT_BASE = "C:\Users\runneradmin\Downloads\Bot"
          $downloads = "C:\Users\runneradmin\Downloads"

          New-Item -ItemType Directory -Force -Path $downloads | Out-Null
          New-Item -ItemType Directory -Force -Path $BOT_BASE | Out-Null

          $tmp = Join-Path $env:TEMP ('botdl_' + [guid]::NewGuid())
          New-Item -ItemType Directory -Force -Path $tmp | Out-Null

          try {
            $zipPath = Join-Path $tmp 'bot.zip'
            Write-Host ("Downloading Bot.zip from {0} ..." -f $env:BOT_ZIP_URL)
            Invoke-WebRequest -Uri $env:BOT_ZIP_URL -OutFile $zipPath -UseBasicParsing

            $extract = Join-Path $tmp 'unzipped'
            Expand-Archive -Path $zipPath -DestinationPath $extract -Force

            $candidates = @(
              (Join-Path $extract 'Bot'),
              (Join-Path $extract 'bot')
            ) | Where-Object { Test-Path $_ }

            if ($candidates.Count -gt 0) {
              $root = $candidates[0]
              Write-Host ("Found root folder in archive: {0}" -f $root)
              Copy-Item -Path (Join-Path $root '*') -Destination $BOT_BASE -Recurse -Force
            } else {
              Write-Host "No root 'Bot' folder; copying all extracted files into BOT_BASE"
              Copy-Item -Path (Join-Path $extract '*') -Destination $BOT_BASE -Recurse -Force
            }

            Write-Host "Downloads directory listing:"
            Get-ChildItem -Force $downloads | Select-Object Name,Length,LastWriteTime | Format-Table -AutoSize
            Write-Host "Bot directory listing:"
            Get-ChildItem -Force $BOT_BASE | Select-Object Name,Length,LastWriteTime | Format-Table -AutoSize

          } finally {
            try { Remove-Item -LiteralPath $tmp -Recurse -Force -ErrorAction SilentlyContinue } catch {}
          }

      - name: Launch bots (start-bots.bat) from fixed path
        shell: pwsh
        run: |
          $BOT_BASE = "C:\Users\runneradmin\Downloads\Bot"
          $bat = Join-Path $BOT_BASE 'start-bots.bat'
          if (-not (Test-Path $bat)) { throw ("start-bots.bat not found at {0}" -f $bat) }
          Write-Host "Launching bots via start-bots.bat ..."
          $psi = New-Object System.Diagnostics.ProcessStartInfo
          $psi.FileName = $bat
          $psi.WorkingDirectory = $BOT_BASE
          $psi.UseShellExecute = $true
          $psi.WindowStyle = 'Normal'
          [void][System.Diagnostics.Process]::Start($psi)

      - name: Keep session open (fixed window, heartbeat)
        shell: pwsh
        run: |
          $minutes = 180
          $interval = 20
          $loops = [Math]::Ceiling(($minutes * 60) / $interval)
          Write-Host ("Holding session open for {0} minutes with {1}s heartbeat..." -f $minutes, $interval)
          for ($i = 1; $i -le $loops; $i++) {
            Write-Host ("Heartbeat {0}/{1}  (remaining ~{2} min)" -f $i, $loops, [Math]::Round(($loops - $i) * $interval / 60.0, 1))
            Start-Sleep -Seconds $interval
          }
          Write-Host "Fixed hold complete."

      - name: Upload ngrok URL file
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ngrok-url
          path: C:\Users\runneradmin\ngrok\ngrok-url.txt
          if-no-files-found: warn

      - name: Final Status
        if: always()
        shell: pwsh
        run: |
          Write-Host ("Pipeline finished for instance {0}." -f $env:INSTANCE_ID)
