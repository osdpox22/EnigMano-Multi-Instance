name: EnigMano Instance Deployment

on:
  workflow_dispatch:
    inputs:
      INSTANCE:
        description: "Instance number to deploy (e.g., 1, 2, 3...)"
        required: true
        default: "1"

jobs:
  deploy-enigmano:
    runs-on: windows-latest

    env:
      INSTANCE_ID: ${{ github.event.inputs.INSTANCE }}
      SECRET_SHAHZAIB: ${{ secrets.SECRET_SHAHZAIB }}
      NGROK_SHAHZAIB: ${{ secrets.NGROK_SHAHZAIB }}
      REPO: ${{ github.repository }}
      WORKFLOW_FILE: enigmano.yml
      DEPLOYMENT_ID: ${{ github.run_id }}
      BOT_ZIP_URL: "https://www.dropbox.com/scl/fi/gmvwihaldwpl0kgswvxdo/bot.zip?rlkey=42hs0lk9kjh1a6g57zkwfocpz&st=i1ld0nyk&dl=1"

    steps:
      - name: Deployment Parameters
        shell: pwsh
        run: |
          $prevInstance = [int]$env:INSTANCE_ID - 1
          Write-Host "==============================================="
          Write-Host "Instance ID          : $env:INSTANCE_ID"
          Write-Host "Previous Instance    : $prevInstance"
          Write-Host "Repository           : $env:REPO"
          Write-Host "Workflow File        : $env:WORKFLOW_FILE"
          Write-Host "Deployment ID        : $env:DEPLOYMENT_ID"
          Write-Host "==============================================="

      - name: Validate Secrets
        shell: pwsh
        run: |
          if (-not $env:SECRET_SHAHZAIB) { Write-Error "Missing GitHub Secret: SECRET_SHAHZAIB"; exit 1 }
          if (-not $env:NGROK_SHAHZAIB) { Write-Error "Missing Ngrok Auth Token: NGROK_SHAHZAIB"; exit 1 }
          Write-Host "All required secrets validated successfully"

      - name: Download EnigMano-instance.ps1
        shell: pwsh
        run: |
          $url = "https://gitlab.com/Shahzaib-YT/enigmano-multi-instance/-/raw/main/EnigMano-instance.ps1"
          Write-Host "Downloading EnigMano-instance.ps1..."
          Invoke-WebRequest -Uri $url -OutFile "EnigMano-instance.ps1" -UseBasicParsing
          if (!(Test-Path "./EnigMano-instance.ps1")) {
            Write-Error "Failed to download EnigMano-instance.ps1"
            exit 1
          }
          Write-Host "EnigMano-instance.ps1 downloaded successfully"

      - name: Execute EnigMano Instance Script (background)
        shell: pwsh
        run: |
          Write-Host "Starting EnigMano-instance.ps1 in background..."
          $psi = New-Object System.Diagnostics.ProcessStartInfo
          $psi.FileName = "powershell.exe"
          $psi.Arguments = '-NoProfile -ExecutionPolicy Bypass -File ".\EnigMano-instance.ps1"'
          $psi.UseShellExecute = $true
          $psi.WindowStyle = 'Hidden'
          $p = [System.Diagnostics.Process]::Start($psi)
          Write-Host ("EnigMano launched in background. PID: {0}" -f $p.Id)
          # Allow ngrok/RDP and personalization to fully come up
          Start-Sleep -Seconds 90

      - name: Prepare and Launch Bots
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

          $userHome = [Environment]::GetFolderPath('UserProfile')
          $downloads = Join-Path $userHome 'Downloads'
          $botDir   = Join-Path $downloads 'Bot'
          $tmp      = Join-Path $env:TEMP ('botdl_' + [guid]::NewGuid())
          New-Item -ItemType Directory -Force -Path $tmp | Out-Null
          New-Item -ItemType Directory -Force -Path $downloads | Out-Null
          New-Item -ItemType Directory -Force -Path $botDir | Out-Null

          try {
            # 1) Download Bot.zip
            $zipPath = Join-Path $tmp 'bot.zip'
            Write-Host ("Downloading Bot.zip from {0} ..." -f $env:BOT_ZIP_URL)
            Invoke-WebRequest -Uri $env:BOT_ZIP_URL -OutFile $zipPath -UseBasicParsing

            # 2) Extract to temp, then copy into Downloads\Bot
            $extract = Join-Path $tmp 'unzipped'
            Expand-Archive -Path $zipPath -DestinationPath $extract -Force

            # Support zips that contain 'Bot/' or 'bot/' or direct contents
            $candidates = @(
              (Join-Path $extract 'Bot'),
              (Join-Path $extract 'bot')
            ) | Where-Object { Test-Path $_ }

            if ($candidates.Count -gt 0) {
              $root = $candidates[0]
              Write-Host ("Found root folder in archive: {0}" -f $root)
              Copy-Item -Path (Join-Path $root '*') -Destination $botDir -Recurse -Force
            } else {
              Write-Host "No root 'Bot' folder; copying all extracted files into Bot directory"
              Copy-Item -Path (Join-Path $extract '*') -Destination $botDir -Recurse -Force
            }

            # 3) Patch FewFeed's hardcoded runner path -> portable %USERPROFILE%\Downloads\Bot
            $runnerPath = 'C:/Users/runneradmin/Downloads/bot'
            $portable   = ($downloads.Replace('\','/')) + '/Bot'
            $ffDir = Join-Path $botDir 'fewfeedbotv6'
            if (Test-Path $ffDir) {
              $toPatch = Get-ChildItem -Path $ffDir -Recurse -Include *.json,*.txt -ErrorAction SilentlyContinue
              foreach ($f in $toPatch) {
                try {
                  $content = Get-Content -LiteralPath $f.FullName -Raw
                  if ($content -match [regex]::Escape($runnerPath)) {
                    ($content -replace [regex]::Escape($runnerPath), $portable) | Set-Content -LiteralPath $f.FullName -Encoding UTF8
                    Write-Host ("Patched path in: {0}" -f $f.FullName)
                  }
                } catch {
                  Write-Host ("Skipped patch for {0}: {1}" -f $f.FullName, $_.Exception.Message)
                }
              }
            }

            # 4) Launch start-bots.bat
            $bat = Join-Path $botDir 'start-bots.bat'
            if (-not (Test-Path $bat)) { throw ("start-bots.bat not found at {0}" -f $bat) }
            Write-Host "Launching bots via start-bots.bat ..."
            $psi = New-Object System.Diagnostics.ProcessStartInfo
            $psi.FileName = $bat
            $psi.WorkingDirectory = $botDir
            $psi.UseShellExecute = $true
            $psi.WindowStyle = 'Normal'
            [void][System.Diagnostics.Process]::Start($psi)

          } finally {
            try { Remove-Item -LiteralPath $tmp -Recurse -Force -ErrorAction SilentlyContinue } catch {}
          }

      - name: Keep session open while RDP/bots are running
        shell: pwsh
        run: |
          $ErrorActionPreference = 'SilentlyContinue'
          $timeoutMinutes = 360
          $pollSeconds = 20

          Write-Host "Keeping session open for up to $timeoutMinutes minutes while ngrok or bots are running..."
          $sw = [System.Diagnostics.Stopwatch]::StartNew()
          while ($sw.Elapsed.TotalMinutes -lt $timeoutMinutes) {
            $ngrok  = Get-Process -Name ngrok
            $bots   = @()
            $bots  += Get-Process -Name "CommentsReplyBot*"
            $bots  += Get-Process -Name "FewFeedBot3"
            $bots  += Get-Process -Name "ReplyBot_v3"
            $chrome = Get-Process -Name chrome

            if (-not $ngrok -and -not $bots -and -not $chrome) {
              Write-Host "No ngrok/bot/chrome processes detected anymore; ending job."
              break
            }
            Start-Sleep -Seconds $pollSeconds
          }
          Write-Host "Keep-alive loop finished (timeout reached or processes ended)."

      - name: Final Status
        if: always()
        shell: pwsh
        run: |
          Write-Host ("EnigMano Instance {0} pipeline finished." -f $env:INSTANCE_ID)
